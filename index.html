<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ollama Speech Interface</title>
    <style>
        .div-col {
            display: flex;
            flex-direction: column;
        }

        .div-row {
            display: flex;
            flex-direction: row;
        }

        .center {
            justify-content: center;
            align-items: center;
        }
    </style>
    <script defer src="fontawesome/all.js"></script>
    <!-- import JavaScript for Vue -->
    <script src="vue/vue.js"></script>
    <script src="vue/index.js"></script>
    <script src="vue/en.js"></script>
</head>

<body>
    <div id="app">
        <div>Talk to the Ollama REST API. Speak the word "prompt" as the wake word.</div>
        <select id="voicesDropdown" style="min-height: 40px; min-width: 500px;">
            <option v-if="speechSynthesisVoices.length == 0" value="">Select a voice</option>
            <option v-for="item in speechSynthesisVoices" :value="item.voiceURI">{{ item.name }} ({{ item.lang }})
            </option>
        </select>
        <div id="txtError"></div>
        <div class="div-col" style="margin: 20px">
            <div>History:</div>
            <div v-for="(item, index) in history" :index="index" class="div-row center"
                style="justify-content: space-between; border: solid 1px black; background: #ddd; gap: 20px">
                <div class="div-row" style="flex-wrap: nowrap">
                    <button @click="handleDeleteHistoryItem(index)">delete</button>
                </div>
                <input type="text" style="margin: 5px; padding: 10px; width: 50%; background: #ffd; border: solid 1px black"
                    :value="item.input"></input>
                <textarea ref="txtHistoryOutput" disabled cols="80"
                    style="width: 50%; height: auto; background: #dfd; border: solid 1px black">{{ item.output }}</textarea>
            </div>
        </div>
        <div class="div-row center"
            style="border: solid 1px black; margin: 20px; background: #eee; padding: 10px; gap: 10px">
            <div>Prompt:</div>
            <input type="text" style="background: #fdd; border: solid 1px red; width: 100%; padding: 10px"
                :value="currentInput" @input="handleTextInput" v-on:keyup.enter="sendToOllama(currentInput)"></input>
            <button style="background: #dfd; margin: 0px; padding: 10px;"
                @click="sendToOllama(currentInput)">Send</button>
        </div>
    </div>
    <script>

        vue = new Vue({
            el: '#app',
            data: {
                speechSynthesisVoices: [],
                currentInput: '',
                history: [],
                ollamaInput: '',
                abortSpeaking: false,
            },
            methods: {
                resizeTextAreaHistory(index) {
                    var refThis = this;
                    setTimeout(function () {
                        refThis.$refs['txtHistoryOutput'][index].style.height = refThis.$refs['txtHistoryOutput'][index].scrollHeight + 'px';
                    }, 0);
                },
                handleDeleteHistoryItem(index) {
                    this.history.splice(index, 1);
                },
                handleTextInput(event) {
                    this.currentInput = event.target.value;
                },
                sendToOllama(input) {
                    var refThis = this;
                    refThis.currentInput = '';

                    const speechSynthesis = window.speechSynthesis;

                    if (speechSynthesis && speechSynthesis.speaking) {
                        refThis.abortSpeaking = true;
                        setTimeout(function () {
                            refThis.abortSpeaking = false;
                        }, 250);
                        if (speechSynthesis && speechSynthesis.cancel) {
                            speechSynthesis.cancel();
                        }
                    }

                    if (!input) {
                        return;
                    }

                    refThis.ollamaInput = input;

                    // manipulate the chat history
                    let messages = [];
                    for (let i = 0; i < refThis.history.length; ++i) {
                        messages.push({
                            "role": "user",
                            "content": refThis.history[i].input,
                        });
                    }
                    messages.push({
                        "role": "user",
                        "content": input,
                    });

                    //console.log('Message Body', JSON.stringify(messages, null, 2));

                    // Define the request body
                    var requestBody = JSON.stringify({
                        "model": "llama2",
                        "messages": messages
                    });

                    // Send the request using Fetch API
                    fetch("http://localhost:11434/api/chat", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: requestBody
                    })
                        .then(async response => {
                            let text = await response.text();
                            //console.log("Text:", text);
                            // replace newlines with commas
                            text = text.split("\n").join(',');
                            if (text.endsWith(',')) {
                                // remove trailing comma
                                text = text.substring(0, text.length - 1);
                            }
                            // add brackets to make into array
                            text = '[' + text + ']';
                            //debugLog(JSON.stringify(JSON.parse(text), null, 2));
                            return text;
                        })
                        .then(async text => {
                            const json = JSON.parse(text);
                            //console.log("JSON:", json);
                            // combine messages into one string
                            let content = '';
                            for (let i = 0; i < json.length; i++) {
                                content += json[i]["message"]["content"];
                            }
                            if (!content) {
                                refThis.history.push({
                                    input: refThis.ollamaInput,
                                    output: '(empty response)',
                                });
                                refThis.currentInput = '';
                                refThis.ollamaInput = '';
                                refThis.resizeTextAreaHistory(refThis.history.length - 1);
                                return;
                            } else {
                                refThis.history.push({
                                    input: refThis.ollamaInput,
                                    output: content,
                                });
                                refThis.resizeTextAreaHistory(refThis.history.length - 1);
                                refThis.currentInput = '';
                                refThis.ollamaInput = '';

                                if (speechSynthesis) {
                                    let words = content.split(' ');
                                    while (words.length > 0) {
                                        let sentence = [];
                                        for (let w = 0; w < 20; w++) {
                                            if (words.length == 0) {
                                                break;
                                            }
                                            const word = words[0];
                                            sentence.push(word);
                                            //console.log('word', word);
                                            words.shift();
                                        }

                                        if (refThis.abortSpeaking) {
                                            console.log('Skip speaking early');
                                            return;
                                        }

                                        let output = sentence.join(' ');
                                        console.log('speak:', output);
                                        const utterance = new SpeechSynthesisUtterance();
                                        utterance.text = output;
                                        if (voicesDropdown.selectedIndex > 0) {
                                            const voice = refThis.speechSynthesisVoices[voicesDropdown.selectedIndex];
                                            utterance.lang = voice.lang;
                                            utterance.localService = voice.localService;
                                            utterance.name = voice.name;
                                            utterance.voiceURI = voice.voiceURI;
                                        } else {
                                            utterance.lang = 'en-US';
                                        }
                                        utterance.volume = 1;
                                        utterance.rate = 1;
                                        utterance.pitch = 1;

                                        speechSynthesis.speak(utterance);

                                        var inProgress = true;
                                        utterance.addEventListener('end', function () {
                                            inProgress = false;
                                        });
                                        while (inProgress) {
                                            if (refThis.abortSpeaking) {
                                                console.log('Skip speaking');
                                                return;
                                            }
                                            await sleep(100);
                                        }
                                    }
                                }
                            }
                        })
                        .catch(error => {
                            showError("Error: " + error);
                        });
                },
            },
        });

        var speechSynthesisVoices = [];

        function debugLog(msg) {
            console.log(msg);
        }

        function showError(msg) {
            debugLog(msg);
            txtError.innerText = msg;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function setupSpeechRecognition() {

            window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!window.SpeechRecognition) {
                showError('Speech Recognition is not supported by your browser!');
                return;
            }

            const recognition = new SpeechRecognition();
            if (!recognition) {
                showError('Could not instantiate SpeechRecognition!');
                return;
            }
            debugLog('Instantiated SpeechRecognition');
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            debugLog('SpeechRecognition: Set default language');

            recognition.addEventListener('result', e => {

                const results = Array.from(e.results);
                if (!results) {
                    return;
                }
                let jsonData = {};
                jsonData.results = [];
                for (let resultIndex = 0; resultIndex < results.length; ++resultIndex) {
                    //console.log(results[resultIndex]);
                    // SpeechRecognitionResult
                    let speechRecognitionResult = {};
                    speechRecognitionResult.isFinal = results[resultIndex].isFinal;
                    speechRecognitionResult.alternatives = [];
                    for (let setIndex = 0; setIndex < results[resultIndex].length; ++setIndex) {
                        //console.log(results[resultIndex][setIndex]);
                        // SpeechRecognitionAlternative
                        let speechRecognitionAlternative = {};
                        speechRecognitionAlternative.confidence = results[resultIndex][setIndex].confidence;
                        speechRecognitionAlternative.transcript = results[resultIndex][setIndex].transcript;
                        speechRecognitionResult.alternatives.push(speechRecognitionAlternative);
                    }
                    speechRecognitionResult.length = speechRecognitionResult.alternatives.length;
                    jsonData.results.push(speechRecognitionResult);
                }
                //debugLog(JSON.stringify(jsonData, null, 2));

                const transcript = Array.from(e.results)
                    .map(result => result[0])
                    .map(result => result.transcript)
                    .join('');

                vue.currentInput = transcript;

                const WAKE_WORD = 'prompt';
                if (e.results[0].isFinal && transcript && transcript.length > 0) {
                    let index = transcript.toLocaleLowerCase().indexOf(WAKE_WORD);
                    if (index < 0) {
                        //debugLog('WAKE WORD NOT DETECTED!');
                        return;
                    }
                    //debugLog('WAKE WORD DETECTED!');
                    const input = transcript.substring(index + WAKE_WORD.length);
                    if (input) {

                        vue.sendToOllama(input);
                    }
                }
            });

            recognition.addEventListener('end', recognition.start);

            if (recognition.start) {
                debugLog('SpeechRecognition has a start method');
                recognition.start();
                debugLog('SpeechRecognition: invoked start method');
            } else {
                showError('SpeechRecognition does not have a start method!');
            }
        }

        function setupSpeechSynthesis() {

            const speechSynthesis = window.speechSynthesis;
            if (!speechSynthesis) {
                showError('Speech Synthesis is not supported by your browser!');
                return;
            }

            if (speechSynthesis.getVoices) {
                setTimeout(function () {
                    vue.speechSynthesisVoices = speechSynthesis.getVoices();
                    //console.log('speechSynthesisVoices', speechSynthesisVoices);

                    for (let i = 0; i < vue.speechSynthesisVoices.length; i++) {
                        if (vue.speechSynthesisVoices[i].lang === 'en-US') {
                            voicesDropdown.selectedIndex = i;
                            break;
                        }
                    }
                }, 100);
            }
        }

        function setup() {

            setupSpeechRecognition();

            setupSpeechSynthesis();

        }

        setup();
    </script>
</body>

</html>